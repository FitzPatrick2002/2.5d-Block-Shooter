export module GameMap;

import Object_3d;
import MapBox;

import TextureManager;
import linAlg;

import ThreadPool;

import <SFML/Graphics.hpp>;
import <vector>;
import <fstream>;
import <filesystem>;
import <functional>;

import <thread>;

// Storing 2d array in a 1d array:
// [i][j] == [i * height + j]

class MapChunk;

// TO DO:
// Add to the map .txt file amount of chunks / size of a chunk

export class GameMap {
private:

	// Width and height m(in tiles) in the world coordinate system
	int width;
	int height;

	sf::Vector2i chunks_amount;

	std::vector<MapBox> ground;
	std::vector<MapBox> groundForDisplay;

	TextureManager* textureManager;

	ThreadPool mapPool;

	std::vector<MapChunk> chunks;

private:

public:

	GameMap();
	~GameMap();

	void init(int w, int h, TextureManager* tM);

	void initChunks(); // Call it after downloading / generatng map, or if map is loaded from file, just read the value

	// Terrain generation

	void generateMap(); // Random walls geenration

	// Paths for enemies generation



	// FOV and drawing

	void setPlayerFOV(sf::Vector3f playerPos, sf::Vector2f absoluteMousePosition);

	void iterateOverWidth(int y, int width, sf::Vector3f playerPos, sf::Vector2f mousePos);

	void setRenderOrder();

	void render(sf::RenderWindow* w);

	// Checkers

	bool checkIfOnMap(sf::Vector2f pos);
	bool checkIfOnMap(sf::Vector2i pos);

	bool checkIfTileWalkable(sf::Vector2f pos);
	bool checkIfTileWalkable(sf::Vector2i pos);

	// Getters and setters

	int getHeight();

	int getWidth();

	sf::Vector2i getChunksAmount();

	MapBox getTile(int i, int j);

	// Saving to file

	void loadFromFile(std::string file_name);

};

export class MapChunk {
private:

	GameMap* map_handle;

	sf::FloatRect dimensions;

	std::vector<sf::Vector2f> waypoints;
	std::vector<std::vector<sf::Vector2f>> routes;

private:

	// Pick some random points inside the rect
	void generateWaypoints();

	// Connect them using A*, Dijkstria, depth first search, who cares
	void connectWaypoints();

	// Find the shortest route by finding the longest possible steps
	// Between next tiles from the path generated by the A*, Dijkstria, etc...
	void shortenRoute();

public:

	MapChunk();
	~MapChunk();

	// It also checks if the rectangle is not being extend outside the map -> then it will make it smaller
	void setDimensions(sf::FloatRect dims);

	void init(GameMap* map, sf::FloatRect dims);

	void generateRoutes();

};